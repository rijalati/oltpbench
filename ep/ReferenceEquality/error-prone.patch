--- src/com/oltpbenchmark/benchmarks/auctionmark/AuctionMarkProfile.java
+++ src/com/oltpbenchmark/benchmarks/auctionmark/AuctionMarkProfile.java
@@ -18,22 +18,4 @@
 package com.oltpbenchmark.benchmarks.auctionmark;
 
-import java.sql.Connection;
-import java.sql.PreparedStatement;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.sql.Timestamp;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.commons.collections15.map.ListOrderedMap;
-import org.apache.log4j.Logger;
-
 import com.oltpbenchmark.benchmarks.auctionmark.procedures.LoadConfig;
 import com.oltpbenchmark.benchmarks.auctionmark.procedures.ResetDatabase;
@@ -57,4 +39,21 @@
 import com.oltpbenchmark.util.SQLUtil;
 import com.oltpbenchmark.util.StringUtil;
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.Timestamp;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+import org.apache.commons.collections15.map.ListOrderedMap;
+import org.apache.log4j.Logger;
 
 
@@ -738,5 +737,5 @@
             // If the items is already in the completed queue, then we don't need
             // to do anything with it.
-            if (items == this.items_completed) continue;
+            if (Objects.equals(items, this.items_completed)) continue;
             
             for (ItemInfo itemInfo : items) {
--- src/com/oltpbenchmark/ThreadBench.java
+++ src/com/oltpbenchmark/ThreadBench.java
@@ -18,4 +18,12 @@
 package com.oltpbenchmark;
 
+import com.oltpbenchmark.LatencyRecord.Sample;
+import com.oltpbenchmark.api.BenchmarkModule;
+import com.oltpbenchmark.api.TransactionType;
+import com.oltpbenchmark.api.Worker;
+import com.oltpbenchmark.types.State;
+import com.oltpbenchmark.util.Histogram;
+import com.oltpbenchmark.util.QueueLimitException;
+import com.oltpbenchmark.util.StringUtil;
 import java.io.File;
 import java.io.IOException;
@@ -28,18 +36,9 @@
 import java.util.Map.Entry;
 import java.util.NoSuchElementException;
+import java.util.Objects;
 import java.util.Set;
-
 import org.apache.commons.collections15.map.ListOrderedMap;
 import org.apache.log4j.Logger;
 
-import com.oltpbenchmark.LatencyRecord.Sample;
-import com.oltpbenchmark.api.BenchmarkModule;
-import com.oltpbenchmark.api.TransactionType;
-import com.oltpbenchmark.api.Worker;
-import com.oltpbenchmark.types.State;
-import com.oltpbenchmark.util.Histogram;
-import com.oltpbenchmark.util.QueueLimitException;
-import com.oltpbenchmark.util.StringUtil;
-
 public class ThreadBench implements Thread.UncaughtExceptionHandler {
     private static final Logger LOG = Logger.getLogger(ThreadBench.class);
@@ -132,5 +131,5 @@
                 // INVALID TXType means all should be reported, if a filter is
                 // set, only this specific transaction
-                if (txType == TransactionType.INVALID || txType.getId() == sample.tranType)
+                if (Objects.equals(txType, TransactionType.INVALID) || txType.getId() == sample.tranType)
                     latencies.add(sample.latencyUs);
 
